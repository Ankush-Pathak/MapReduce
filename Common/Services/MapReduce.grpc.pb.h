// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: MapReduce.proto
#ifndef GRPC_MapReduce_2eproto__INCLUDED
#define GRPC_MapReduce_2eproto__INCLUDED

#include "MapReduce.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

class MapReduce final {
 public:
  static constexpr char const* service_full_name() {
    return "MapReduce";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status startMapReduce(::grpc::ClientContext* context, const ::Config& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncstartMapReduce(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncstartMapReduceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncstartMapReduce(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncstartMapReduceRaw(context, request, cq));
    }
    virtual ::grpc::Status getStatus(::grpc::ClientContext* context, const ::Empty& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void startMapReduce(::grpc::ClientContext* context, const ::Config* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void startMapReduce(::grpc::ClientContext* context, const ::Config* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncstartMapReduceRaw(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncstartMapReduceRaw(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status startMapReduce(::grpc::ClientContext* context, const ::Config& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncstartMapReduce(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncstartMapReduceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncstartMapReduce(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncstartMapReduceRaw(context, request, cq));
    }
    ::grpc::Status getStatus(::grpc::ClientContext* context, const ::Empty& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void startMapReduce(::grpc::ClientContext* context, const ::Config* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void startMapReduce(::grpc::ClientContext* context, const ::Config* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncstartMapReduceRaw(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncstartMapReduceRaw(::grpc::ClientContext* context, const ::Config& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_startMapReduce_;
    const ::grpc::internal::RpcMethod rpcmethod_getStatus_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status startMapReduce(::grpc::ServerContext* context, const ::Config* request, ::Result* response);
    virtual ::grpc::Status getStatus(::grpc::ServerContext* context, const ::Empty* request, ::Result* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_startMapReduce() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartMapReduce(::grpc::ServerContext* context, ::Config* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_startMapReduce<WithAsyncMethod_getStatus<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_startMapReduce() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::Config, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Config* request, ::Result* response) { return this->startMapReduce(context, request, response); }));}
    void SetMessageAllocatorFor_startMapReduce(
        ::grpc::MessageAllocator< ::Config, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Config, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startMapReduce(
      ::grpc::CallbackServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::Result* response) { return this->getStatus(context, request, response); }));}
    void SetMessageAllocatorFor_getStatus(
        ::grpc::MessageAllocator< ::Empty, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_startMapReduce<WithCallbackMethod_getStatus<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_startMapReduce() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_startMapReduce() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartMapReduce(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_startMapReduce() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->startMapReduce(context, request, response); }));
    }
    ~WithRawCallbackMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startMapReduce(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_startMapReduce : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_startMapReduce() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Config, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Config, ::Result>* streamer) {
                       return this->StreamedstartMapReduce(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_startMapReduce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status startMapReduce(::grpc::ServerContext* /*context*/, const ::Config* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedstartMapReduce(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Config,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::Result>* streamer) {
                       return this->StreamedgetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::Result>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_startMapReduce<WithStreamedUnaryMethod_getStatus<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_startMapReduce<WithStreamedUnaryMethod_getStatus<Service > > StreamedService;
};

class MapperService final {
 public:
  static constexpr char const* service_full_name() {
    return "MapperService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::MapperResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> AsyncstartMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(AsyncstartMapperRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> PrepareAsyncstartMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(PrepareAsyncstartMapperRaw(context, request, cq));
    }
    virtual ::grpc::Status getStatus(::grpc::ClientContext* context, const ::Empty& request, ::MapperResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::MapperResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest* request, ::MapperResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* AsyncstartMapperRaw(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* PrepareAsyncstartMapperRaw(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MapperResult>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::MapperResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> AsyncstartMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(AsyncstartMapperRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> PrepareAsyncstartMapper(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(PrepareAsyncstartMapperRaw(context, request, cq));
    }
    ::grpc::Status getStatus(::grpc::ClientContext* context, const ::Empty& request, ::MapperResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::MapperResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MapperResult>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest* request, ::MapperResult* response, std::function<void(::grpc::Status)>) override;
      void startMapper(::grpc::ClientContext* context, const ::MapperConfigRequest* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, std::function<void(::grpc::Status)>) override;
      void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, std::function<void(::grpc::Status)>) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::MapperResult* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* AsyncstartMapperRaw(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* PrepareAsyncstartMapperRaw(::grpc::ClientContext* context, const ::MapperConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MapperResult>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_startMapper_;
    const ::grpc::internal::RpcMethod rpcmethod_getStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_die_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status startMapper(::grpc::ServerContext* context, const ::MapperConfigRequest* request, ::MapperResult* response);
    virtual ::grpc::Status getStatus(::grpc::ServerContext* context, const ::Empty* request, ::MapperResult* response);
    virtual ::grpc::Status die(::grpc::ServerContext* context, const ::Empty* request, ::MapperResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_startMapper() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartMapper(::grpc::ServerContext* context, ::MapperConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::MapperResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::MapperResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_die() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::MapperResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_startMapper<WithAsyncMethod_getStatus<WithAsyncMethod_die<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_startMapper() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::MapperConfigRequest, ::MapperResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::MapperConfigRequest* request, ::MapperResult* response) { return this->startMapper(context, request, response); }));}
    void SetMessageAllocatorFor_startMapper(
        ::grpc::MessageAllocator< ::MapperConfigRequest, ::MapperResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::MapperConfigRequest, ::MapperResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startMapper(
      ::grpc::CallbackServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::MapperResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::MapperResult* response) { return this->getStatus(context, request, response); }));}
    void SetMessageAllocatorFor_getStatus(
        ::grpc::MessageAllocator< ::Empty, ::MapperResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::MapperResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_die() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::MapperResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::MapperResult* response) { return this->die(context, request, response); }));}
    void SetMessageAllocatorFor_die(
        ::grpc::MessageAllocator< ::Empty, ::MapperResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::MapperResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_startMapper<WithCallbackMethod_getStatus<WithCallbackMethod_die<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_startMapper() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_die() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_startMapper() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartMapper(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_die() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_startMapper() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->startMapper(context, request, response); }));
    }
    ~WithRawCallbackMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startMapper(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_die() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->die(context, request, response); }));
    }
    ~WithRawCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_startMapper : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_startMapper() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::MapperConfigRequest, ::MapperResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::MapperConfigRequest, ::MapperResult>* streamer) {
                       return this->StreamedstartMapper(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_startMapper() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status startMapper(::grpc::ServerContext* /*context*/, const ::MapperConfigRequest* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedstartMapper(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MapperConfigRequest,::MapperResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::MapperResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::MapperResult>* streamer) {
                       return this->StreamedgetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::MapperResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_die() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::MapperResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::MapperResult>* streamer) {
                       return this->Streameddie(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::MapperResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddie(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::MapperResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_startMapper<WithStreamedUnaryMethod_getStatus<WithStreamedUnaryMethod_die<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_startMapper<WithStreamedUnaryMethod_getStatus<WithStreamedUnaryMethod_die<Service > > > StreamedService;
};

class ReducerService final {
 public:
  static constexpr char const* service_full_name() {
    return "ReducerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::ReducerResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>> AsyncstartReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>>(AsyncstartReducerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>> PrepareAsyncstartReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>>(PrepareAsyncstartReducerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ReducerResult>> getStatus(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ReducerResult>>(getStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ReducerResult>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ReducerResult>>(AsyncgetStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ReducerResult>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ReducerResult>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response, std::function<void(::grpc::Status)>) = 0;
      virtual void startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::grpc::ClientReadReactor< ::ReducerResult>* reactor) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>* AsyncstartReducerRaw(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ReducerResult>* PrepareAsyncstartReducerRaw(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ReducerResult>* getStatusRaw(::grpc::ClientContext* context, const ::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ReducerResult>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ReducerResult>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::ReducerResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReducerResult>> AsyncstartReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReducerResult>>(AsyncstartReducerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReducerResult>> PrepareAsyncstartReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ReducerResult>>(PrepareAsyncstartReducerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ReducerResult>> getStatus(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ReducerResult>>(getStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ReducerResult>> AsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ReducerResult>>(AsyncgetStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ReducerResult>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ReducerResult>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response, std::function<void(::grpc::Status)>) override;
      void startReducer(::grpc::ClientContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getStatus(::grpc::ClientContext* context, const ::Empty* request, ::grpc::ClientReadReactor< ::ReducerResult>* reactor) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ReducerResult>* AsyncstartReducerRaw(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ReducerResult>* PrepareAsyncstartReducerRaw(::grpc::ClientContext* context, const ::ReducerConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ReducerResult>* getStatusRaw(::grpc::ClientContext* context, const ::Empty& request) override;
    ::grpc::ClientAsyncReader< ::ReducerResult>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ReducerResult>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_startReducer_;
    const ::grpc::internal::RpcMethod rpcmethod_getStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_die_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status startReducer(::grpc::ServerContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response);
    virtual ::grpc::Status getStatus(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::ReducerResult>* writer);
    virtual ::grpc::Status die(::grpc::ServerContext* context, const ::Empty* request, ::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_startReducer() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartReducer(::grpc::ServerContext* context, ::ReducerConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::ReducerResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncWriter< ::ReducerResult>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_die() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_startReducer<WithAsyncMethod_getStatus<WithAsyncMethod_die<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_startReducer() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ReducerConfigRequest, ::ReducerResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ReducerConfigRequest* request, ::ReducerResult* response) { return this->startReducer(context, request, response); }));}
    void SetMessageAllocatorFor_startReducer(
        ::grpc::MessageAllocator< ::ReducerConfigRequest, ::ReducerResult>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ReducerConfigRequest, ::ReducerResult>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startReducer(
      ::grpc::CallbackServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::Empty, ::ReducerResult>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request) { return this->getStatus(context, request); }));
    }
    ~WithCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::ReducerResult>* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_die() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::Empty* response) { return this->die(context, request, response); }));}
    void SetMessageAllocatorFor_die(
        ::grpc::MessageAllocator< ::Empty, ::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_startReducer<WithCallbackMethod_getStatus<WithCallbackMethod_die<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_startReducer() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_die() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_startReducer() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststartReducer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_die() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_startReducer() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->startReducer(context, request, response); }));
    }
    ~WithRawCallbackMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* startReducer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->getStatus(context, request); }));
    }
    ~WithRawCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_die() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->die(context, request, response); }));
    }
    ~WithRawCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_startReducer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_startReducer() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ReducerConfigRequest, ::ReducerResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ReducerConfigRequest, ::ReducerResult>* streamer) {
                       return this->StreamedstartReducer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_startReducer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status startReducer(::grpc::ServerContext* /*context*/, const ::ReducerConfigRequest* /*request*/, ::ReducerResult* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedstartReducer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ReducerConfigRequest,::ReducerResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_die() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::Empty>* streamer) {
                       return this->Streameddie(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddie(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_startReducer<WithStreamedUnaryMethod_die<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_getStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::Empty, ::ReducerResult>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::Empty, ::ReducerResult>* streamer) {
                       return this->StreamedgetStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::ReducerResult>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedgetStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Empty,::ReducerResult>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_getStatus<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_startReducer<WithSplitStreamingMethod_getStatus<WithStreamedUnaryMethod_die<Service > > > StreamedService;
};

class HDFSService final {
 public:
  static constexpr char const* service_full_name() {
    return "HDFSService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientWriterInterface< ::SetRequest>> streamAppend(::grpc::ClientContext* context, ::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::SetRequest>>(streamAppendRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>> AsyncstreamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>>(AsyncstreamAppendRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>> PrepareAsyncstreamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>>(PrepareAsyncstreamAppendRaw(context, response, cq));
    }
    virtual ::grpc::Status set(::grpc::ClientContext* context, const ::SetRequest& request, ::SetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>> Asyncset(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>>(AsyncsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>> PrepareAsyncset(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>>(PrepareAsyncsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::SetRequest>> setStream(::grpc::ClientContext* context, ::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::SetRequest>>(setStreamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>> AsyncsetStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>>(AsyncsetStreamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>> PrepareAsyncsetStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::SetRequest>>(PrepareAsyncsetStreamRaw(context, response, cq));
    }
    virtual ::grpc::Status get(::grpc::ClientContext* context, const ::GetRequest& request, ::GetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>> Asyncget(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>>(AsyncgetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>> PrepareAsyncget(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>>(PrepareAsyncgetRaw(context, request, cq));
    }
    virtual ::grpc::Status append(::grpc::ClientContext* context, const ::SetRequest& request, ::SetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>> Asyncappend(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>>(AsyncappendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>> PrepareAsyncappend(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>>(PrepareAsyncappendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::StreamResponse>> streamData(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::StreamResponse>>(streamDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::StreamResponse>> AsyncstreamData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::StreamResponse>>(AsyncstreamDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::StreamResponse>> PrepareAsyncstreamData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::StreamResponse>>(PrepareAsyncstreamDataRaw(context, request, cq));
    }
    virtual ::grpc::Status getMetaData(::grpc::ClientContext* context, const ::Empty& request, ::HDFSMetaData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>> AsyncgetMetaData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>>(AsyncgetMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>> PrepareAsyncgetMetaData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>>(PrepareAsyncgetMetaDataRaw(context, request, cq));
    }
    virtual ::grpc::Status clear(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> Asyncclear(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncclearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncclear(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncclearRaw(context, request, cq));
    }
    virtual ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void streamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::ClientWriteReactor< ::SetRequest>* reactor) = 0;
      virtual void set(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::ClientWriteReactor< ::SetRequest>* reactor) = 0;
      virtual void get(::grpc::ClientContext* context, const ::GetRequest* request, ::GetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get(::grpc::ClientContext* context, const ::GetRequest* request, ::GetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void append(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void append(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void streamData(::grpc::ClientContext* context, const ::Empty* request, ::grpc::ClientReadReactor< ::StreamResponse>* reactor) = 0;
      virtual void getMetaData(::grpc::ClientContext* context, const ::Empty* request, ::HDFSMetaData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getMetaData(::grpc::ClientContext* context, const ::Empty* request, ::HDFSMetaData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clear(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clear(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientWriterInterface< ::SetRequest>* streamAppendRaw(::grpc::ClientContext* context, ::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::SetRequest>* AsyncstreamAppendRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::SetRequest>* PrepareAsyncstreamAppendRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>* AsyncsetRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>* PrepareAsyncsetRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::SetRequest>* setStreamRaw(::grpc::ClientContext* context, ::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::SetRequest>* AsyncsetStreamRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::SetRequest>* PrepareAsyncsetStreamRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>* AsyncgetRaw(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GetResponse>* PrepareAsyncgetRaw(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>* AsyncappendRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetResponse>* PrepareAsyncappendRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::StreamResponse>* streamDataRaw(::grpc::ClientContext* context, const ::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::StreamResponse>* AsyncstreamDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::StreamResponse>* PrepareAsyncstreamDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>* AsyncgetMetaDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::HDFSMetaData>* PrepareAsyncgetMetaDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncclearRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncclearRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientWriter< ::SetRequest>> streamAppend(::grpc::ClientContext* context, ::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::SetRequest>>(streamAppendRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>> AsyncstreamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>>(AsyncstreamAppendRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>> PrepareAsyncstreamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>>(PrepareAsyncstreamAppendRaw(context, response, cq));
    }
    ::grpc::Status set(::grpc::ClientContext* context, const ::SetRequest& request, ::SetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>> Asyncset(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>>(AsyncsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>> PrepareAsyncset(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>>(PrepareAsyncsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::SetRequest>> setStream(::grpc::ClientContext* context, ::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::SetRequest>>(setStreamRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>> AsyncsetStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>>(AsyncsetStreamRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>> PrepareAsyncsetStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::SetRequest>>(PrepareAsyncsetStreamRaw(context, response, cq));
    }
    ::grpc::Status get(::grpc::ClientContext* context, const ::GetRequest& request, ::GetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetResponse>> Asyncget(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetResponse>>(AsyncgetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetResponse>> PrepareAsyncget(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GetResponse>>(PrepareAsyncgetRaw(context, request, cq));
    }
    ::grpc::Status append(::grpc::ClientContext* context, const ::SetRequest& request, ::SetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>> Asyncappend(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>>(AsyncappendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>> PrepareAsyncappend(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetResponse>>(PrepareAsyncappendRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::StreamResponse>> streamData(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::StreamResponse>>(streamDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::StreamResponse>> AsyncstreamData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::StreamResponse>>(AsyncstreamDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::StreamResponse>> PrepareAsyncstreamData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::StreamResponse>>(PrepareAsyncstreamDataRaw(context, request, cq));
    }
    ::grpc::Status getMetaData(::grpc::ClientContext* context, const ::Empty& request, ::HDFSMetaData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>> AsyncgetMetaData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>>(AsyncgetMetaDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>> PrepareAsyncgetMetaData(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>>(PrepareAsyncgetMetaDataRaw(context, request, cq));
    }
    ::grpc::Status clear(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> Asyncclear(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncclearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncclear(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncclearRaw(context, request, cq));
    }
    ::grpc::Status die(::grpc::ClientContext* context, const ::Empty& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> Asyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncdieRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncdie(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncdieRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void streamAppend(::grpc::ClientContext* context, ::Empty* response, ::grpc::ClientWriteReactor< ::SetRequest>* reactor) override;
      void set(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, std::function<void(::grpc::Status)>) override;
      void set(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setStream(::grpc::ClientContext* context, ::Empty* response, ::grpc::ClientWriteReactor< ::SetRequest>* reactor) override;
      void get(::grpc::ClientContext* context, const ::GetRequest* request, ::GetResponse* response, std::function<void(::grpc::Status)>) override;
      void get(::grpc::ClientContext* context, const ::GetRequest* request, ::GetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void append(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, std::function<void(::grpc::Status)>) override;
      void append(::grpc::ClientContext* context, const ::SetRequest* request, ::SetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void streamData(::grpc::ClientContext* context, const ::Empty* request, ::grpc::ClientReadReactor< ::StreamResponse>* reactor) override;
      void getMetaData(::grpc::ClientContext* context, const ::Empty* request, ::HDFSMetaData* response, std::function<void(::grpc::Status)>) override;
      void getMetaData(::grpc::ClientContext* context, const ::Empty* request, ::HDFSMetaData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clear(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) override;
      void clear(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, std::function<void(::grpc::Status)>) override;
      void die(::grpc::ClientContext* context, const ::Empty* request, ::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientWriter< ::SetRequest>* streamAppendRaw(::grpc::ClientContext* context, ::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::SetRequest>* AsyncstreamAppendRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::SetRequest>* PrepareAsyncstreamAppendRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SetResponse>* AsyncsetRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SetResponse>* PrepareAsyncsetRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::SetRequest>* setStreamRaw(::grpc::ClientContext* context, ::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::SetRequest>* AsyncsetStreamRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::SetRequest>* PrepareAsyncsetStreamRaw(::grpc::ClientContext* context, ::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GetResponse>* AsyncgetRaw(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GetResponse>* PrepareAsyncgetRaw(::grpc::ClientContext* context, const ::GetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SetResponse>* AsyncappendRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SetResponse>* PrepareAsyncappendRaw(::grpc::ClientContext* context, const ::SetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::StreamResponse>* streamDataRaw(::grpc::ClientContext* context, const ::Empty& request) override;
    ::grpc::ClientAsyncReader< ::StreamResponse>* AsyncstreamDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::StreamResponse>* PrepareAsyncstreamDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>* AsyncgetMetaDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::HDFSMetaData>* PrepareAsyncgetMetaDataRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncclearRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncclearRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncdieRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_streamAppend_;
    const ::grpc::internal::RpcMethod rpcmethod_set_;
    const ::grpc::internal::RpcMethod rpcmethod_setStream_;
    const ::grpc::internal::RpcMethod rpcmethod_get_;
    const ::grpc::internal::RpcMethod rpcmethod_append_;
    const ::grpc::internal::RpcMethod rpcmethod_streamData_;
    const ::grpc::internal::RpcMethod rpcmethod_getMetaData_;
    const ::grpc::internal::RpcMethod rpcmethod_clear_;
    const ::grpc::internal::RpcMethod rpcmethod_die_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status streamAppend(::grpc::ServerContext* context, ::grpc::ServerReader< ::SetRequest>* reader, ::Empty* response);
    virtual ::grpc::Status set(::grpc::ServerContext* context, const ::SetRequest* request, ::SetResponse* response);
    virtual ::grpc::Status setStream(::grpc::ServerContext* context, ::grpc::ServerReader< ::SetRequest>* reader, ::Empty* response);
    virtual ::grpc::Status get(::grpc::ServerContext* context, const ::GetRequest* request, ::GetResponse* response);
    virtual ::grpc::Status append(::grpc::ServerContext* context, const ::SetRequest* request, ::SetResponse* response);
    virtual ::grpc::Status streamData(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::StreamResponse>* writer);
    virtual ::grpc::Status getMetaData(::grpc::ServerContext* context, const ::Empty* request, ::HDFSMetaData* response);
    virtual ::grpc::Status clear(::grpc::ServerContext* context, const ::Empty* request, ::Empty* response);
    virtual ::grpc::Status die(::grpc::ServerContext* context, const ::Empty* request, ::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_streamAppend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamAppend() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_streamAppend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAppend(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamAppend(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::Empty, ::SetRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset(::grpc::ServerContext* context, ::SetRequest* request, ::grpc::ServerAsyncResponseWriter< ::SetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setStream() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_setStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::Empty, ::SetRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget(::grpc::ServerContext* context, ::GetRequest* request, ::grpc::ServerAsyncResponseWriter< ::GetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_append() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestappend(::grpc::ServerContext* context, ::SetRequest* request, ::grpc::ServerAsyncResponseWriter< ::SetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamData(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncWriter< ::StreamResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getMetaData() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMetaData(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::HDFSMetaData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clear() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_die() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_streamAppend<WithAsyncMethod_set<WithAsyncMethod_setStream<WithAsyncMethod_get<WithAsyncMethod_append<WithAsyncMethod_streamData<WithAsyncMethod_getMetaData<WithAsyncMethod_clear<WithAsyncMethod_die<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_streamAppend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_streamAppend() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackClientStreamingHandler< ::SetRequest, ::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, ::Empty* response) { return this->streamAppend(context, response); }));
    }
    ~WithCallbackMethod_streamAppend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAppend(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::SetRequest>* streamAppend(
      ::grpc::CallbackServerContext* /*context*/, ::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::SetRequest, ::SetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::SetRequest* request, ::SetResponse* response) { return this->set(context, request, response); }));}
    void SetMessageAllocatorFor_set(
        ::grpc::MessageAllocator< ::SetRequest, ::SetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SetRequest, ::SetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set(
      ::grpc::CallbackServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setStream() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::SetRequest, ::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, ::Empty* response) { return this->setStream(context, response); }));
    }
    ~WithCallbackMethod_setStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::SetRequest>* setStream(
      ::grpc::CallbackServerContext* /*context*/, ::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::GetRequest, ::GetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GetRequest* request, ::GetResponse* response) { return this->get(context, request, response); }));}
    void SetMessageAllocatorFor_get(
        ::grpc::MessageAllocator< ::GetRequest, ::GetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GetRequest, ::GetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get(
      ::grpc::CallbackServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_append() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::SetRequest, ::SetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::SetRequest* request, ::SetResponse* response) { return this->append(context, request, response); }));}
    void SetMessageAllocatorFor_append(
        ::grpc::MessageAllocator< ::SetRequest, ::SetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SetRequest, ::SetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* append(
      ::grpc::CallbackServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_streamData() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::Empty, ::StreamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request) { return this->streamData(context, request); }));
    }
    ~WithCallbackMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::StreamResponse>* streamData(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getMetaData() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::HDFSMetaData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::HDFSMetaData* response) { return this->getMetaData(context, request, response); }));}
    void SetMessageAllocatorFor_getMetaData(
        ::grpc::MessageAllocator< ::Empty, ::HDFSMetaData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::HDFSMetaData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMetaData(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clear() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::Empty* response) { return this->clear(context, request, response); }));}
    void SetMessageAllocatorFor_clear(
        ::grpc::MessageAllocator< ::Empty, ::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_die() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Empty* request, ::Empty* response) { return this->die(context, request, response); }));}
    void SetMessageAllocatorFor_die(
        ::grpc::MessageAllocator< ::Empty, ::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Empty, ::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_streamAppend<WithCallbackMethod_set<WithCallbackMethod_setStream<WithCallbackMethod_get<WithCallbackMethod_append<WithCallbackMethod_streamData<WithCallbackMethod_getMetaData<WithCallbackMethod_clear<WithCallbackMethod_die<Service > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_streamAppend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamAppend() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_streamAppend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAppend(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setStream() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_setStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_append() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getMetaData() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clear() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_die() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamAppend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamAppend() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_streamAppend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAppend(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamAppend(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setStream() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_setStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetStream(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_append() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestappend(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamData() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getMetaData() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMetaData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clear() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_die() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdie(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_streamAppend : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_streamAppend() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->streamAppend(context, response); }));
    }
    ~WithRawCallbackMethod_streamAppend() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAppend(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* streamAppend(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set(context, request, response); }));
    }
    ~WithRawCallbackMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setStream : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setStream() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->setStream(context, response); }));
    }
    ~WithRawCallbackMethod_setStream() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setStream(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::SetRequest>* /*reader*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* setStream(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get(context, request, response); }));
    }
    ~WithRawCallbackMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_append() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->append(context, request, response); }));
    }
    ~WithRawCallbackMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* append(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_streamData() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->streamData(context, request); }));
    }
    ~WithRawCallbackMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getMetaData() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMetaData(context, request, response); }));
    }
    ~WithRawCallbackMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMetaData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clear() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clear(context, request, response); }));
    }
    ~WithRawCallbackMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_die() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->die(context, request, response); }));
    }
    ~WithRawCallbackMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* die(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SetRequest, ::SetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SetRequest, ::SetResponse>* streamer) {
                       return this->Streamedset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SetRequest,::SetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GetRequest, ::GetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GetRequest, ::GetResponse>* streamer) {
                       return this->Streamedget(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get(::grpc::ServerContext* /*context*/, const ::GetRequest* /*request*/, ::GetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GetRequest,::GetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_append : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_append() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SetRequest, ::SetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SetRequest, ::SetResponse>* streamer) {
                       return this->Streamedappend(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_append() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status append(::grpc::ServerContext* /*context*/, const ::SetRequest* /*request*/, ::SetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedappend(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SetRequest,::SetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getMetaData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getMetaData() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::HDFSMetaData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::HDFSMetaData>* streamer) {
                       return this->StreamedgetMetaData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getMetaData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getMetaData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::HDFSMetaData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetMetaData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::HDFSMetaData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clear() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::Empty>* streamer) {
                       return this->Streamedclear(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclear(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_die : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_die() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Empty, ::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Empty, ::Empty>* streamer) {
                       return this->Streameddie(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_die() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status die(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddie(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_set<WithStreamedUnaryMethod_get<WithStreamedUnaryMethod_append<WithStreamedUnaryMethod_getMetaData<WithStreamedUnaryMethod_clear<WithStreamedUnaryMethod_die<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_streamData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::Empty, ::StreamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::Empty, ::StreamResponse>* streamer) {
                       return this->StreamedstreamData(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamData(::grpc::ServerContext* /*context*/, const ::Empty* /*request*/, ::grpc::ServerWriter< ::StreamResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamData(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Empty,::StreamResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_streamData<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_set<WithStreamedUnaryMethod_get<WithStreamedUnaryMethod_append<WithSplitStreamingMethod_streamData<WithStreamedUnaryMethod_getMetaData<WithStreamedUnaryMethod_clear<WithStreamedUnaryMethod_die<Service > > > > > > > StreamedService;
};


#endif  // GRPC_MapReduce_2eproto__INCLUDED
