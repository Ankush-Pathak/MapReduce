// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapReduce.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MapReduce_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MapReduce_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MapReduce_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MapReduce_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MapReduce_2eproto;
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class HDFSMetaData;
struct HDFSMetaDataDefaultTypeInternal;
extern HDFSMetaDataDefaultTypeInternal _HDFSMetaData_default_instance_;
class Host;
struct HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class MapperConfigRequest;
struct MapperConfigRequestDefaultTypeInternal;
extern MapperConfigRequestDefaultTypeInternal _MapperConfigRequest_default_instance_;
class MapperResult;
struct MapperResultDefaultTypeInternal;
extern MapperResultDefaultTypeInternal _MapperResult_default_instance_;
class ReducerConfigRequest;
struct ReducerConfigRequestDefaultTypeInternal;
extern ReducerConfigRequestDefaultTypeInternal _ReducerConfigRequest_default_instance_;
class ReducerKeys;
struct ReducerKeysDefaultTypeInternal;
extern ReducerKeysDefaultTypeInternal _ReducerKeys_default_instance_;
class ReducerResult;
struct ReducerResultDefaultTypeInternal;
extern ReducerResultDefaultTypeInternal _ReducerResult_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class SetRequest;
struct SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class SetRequestStream;
struct SetRequestStreamDefaultTypeInternal;
extern SetRequestStreamDefaultTypeInternal _SetRequestStream_default_instance_;
class SetResponse;
struct SetResponseDefaultTypeInternal;
extern SetResponseDefaultTypeInternal _SetResponse_default_instance_;
class StreamResponse;
struct StreamResponseDefaultTypeInternal;
extern StreamResponseDefaultTypeInternal _StreamResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Config* Arena::CreateMaybeMessage<::Config>(Arena*);
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::GetRequest* Arena::CreateMaybeMessage<::GetRequest>(Arena*);
template<> ::GetResponse* Arena::CreateMaybeMessage<::GetResponse>(Arena*);
template<> ::HDFSMetaData* Arena::CreateMaybeMessage<::HDFSMetaData>(Arena*);
template<> ::Host* Arena::CreateMaybeMessage<::Host>(Arena*);
template<> ::MapperConfigRequest* Arena::CreateMaybeMessage<::MapperConfigRequest>(Arena*);
template<> ::MapperResult* Arena::CreateMaybeMessage<::MapperResult>(Arena*);
template<> ::ReducerConfigRequest* Arena::CreateMaybeMessage<::ReducerConfigRequest>(Arena*);
template<> ::ReducerKeys* Arena::CreateMaybeMessage<::ReducerKeys>(Arena*);
template<> ::ReducerResult* Arena::CreateMaybeMessage<::ReducerResult>(Arena*);
template<> ::Result* Arena::CreateMaybeMessage<::Result>(Arena*);
template<> ::SetRequest* Arena::CreateMaybeMessage<::SetRequest>(Arena*);
template<> ::SetRequestStream* Arena::CreateMaybeMessage<::SetRequestStream>(Arena*);
template<> ::SetResponse* Arena::CreateMaybeMessage<::SetResponse>(Arena*);
template<> ::StreamResponse* Arena::CreateMaybeMessage<::StreamResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Host final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Host) */ {
 public:
  inline Host() : Host(nullptr) {}
  ~Host() override;
  explicit PROTOBUF_CONSTEXPR Host(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Host(const Host& from);
  Host(Host&& from) noexcept
    : Host() {
    *this = ::std::move(from);
  }

  inline Host& operator=(const Host& from) {
    CopyFrom(from);
    return *this;
  }
  inline Host& operator=(Host&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Host& default_instance() {
    return *internal_default_instance();
  }
  static inline const Host* internal_default_instance() {
    return reinterpret_cast<const Host*>(
               &_Host_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Host& a, Host& b) {
    a.Swap(&b);
  }
  inline void Swap(Host* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Host* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Host* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Host>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Host& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Host& from) {
    Host::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Host* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Host";
  }
  protected:
  explicit Host(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string host = 1;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string port = 2;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // @@protoc_insertion_point(class_scope:Host)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit PROTOBUF_CONSTEXPR Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMappersFieldNumber = 11,
    kReducersFieldNumber = 12,
    kFileHostFieldNumber = 3,
    kInputFilePathFieldNumber = 4,
    kMapperFilePathFieldNumber = 5,
    kReducerFilePathFieldNumber = 6,
    kOutputHDFSFieldNumber = 9,
  };
  // repeated .Host mappers = 11;
  int mappers_size() const;
  private:
  int _internal_mappers_size() const;
  public:
  void clear_mappers();
  ::Host* mutable_mappers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
      mutable_mappers();
  private:
  const ::Host& _internal_mappers(int index) const;
  ::Host* _internal_add_mappers();
  public:
  const ::Host& mappers(int index) const;
  ::Host* add_mappers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
      mappers() const;

  // repeated .Host reducers = 12;
  int reducers_size() const;
  private:
  int _internal_reducers_size() const;
  public:
  void clear_reducers();
  ::Host* mutable_reducers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
      mutable_reducers();
  private:
  const ::Host& _internal_reducers(int index) const;
  ::Host* _internal_add_reducers();
  public:
  const ::Host& reducers(int index) const;
  ::Host* add_reducers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
      reducers() const;

  // optional string fileHost = 3;
  bool has_filehost() const;
  private:
  bool _internal_has_filehost() const;
  public:
  void clear_filehost();
  const std::string& filehost() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filehost(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filehost();
  PROTOBUF_NODISCARD std::string* release_filehost();
  void set_allocated_filehost(std::string* filehost);
  private:
  const std::string& _internal_filehost() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filehost(const std::string& value);
  std::string* _internal_mutable_filehost();
  public:

  // string inputFilePath = 4;
  void clear_inputfilepath();
  const std::string& inputfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inputfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inputfilepath();
  PROTOBUF_NODISCARD std::string* release_inputfilepath();
  void set_allocated_inputfilepath(std::string* inputfilepath);
  private:
  const std::string& _internal_inputfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inputfilepath(const std::string& value);
  std::string* _internal_mutable_inputfilepath();
  public:

  // string mapperFilePath = 5;
  void clear_mapperfilepath();
  const std::string& mapperfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapperfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapperfilepath();
  PROTOBUF_NODISCARD std::string* release_mapperfilepath();
  void set_allocated_mapperfilepath(std::string* mapperfilepath);
  private:
  const std::string& _internal_mapperfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapperfilepath(const std::string& value);
  std::string* _internal_mutable_mapperfilepath();
  public:

  // string reducerFilePath = 6;
  void clear_reducerfilepath();
  const std::string& reducerfilepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reducerfilepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reducerfilepath();
  PROTOBUF_NODISCARD std::string* release_reducerfilepath();
  void set_allocated_reducerfilepath(std::string* reducerfilepath);
  private:
  const std::string& _internal_reducerfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reducerfilepath(const std::string& value);
  std::string* _internal_mutable_reducerfilepath();
  public:

  // .Host outputHDFS = 9;
  bool has_outputhdfs() const;
  private:
  bool _internal_has_outputhdfs() const;
  public:
  void clear_outputhdfs();
  const ::Host& outputhdfs() const;
  PROTOBUF_NODISCARD ::Host* release_outputhdfs();
  ::Host* mutable_outputhdfs();
  void set_allocated_outputhdfs(::Host* outputhdfs);
  private:
  const ::Host& _internal_outputhdfs() const;
  ::Host* _internal_mutable_outputhdfs();
  public:
  void unsafe_arena_set_allocated_outputhdfs(
      ::Host* outputhdfs);
  ::Host* unsafe_arena_release_outputhdfs();

  // @@protoc_insertion_point(class_scope:Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host > mappers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host > reducers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filehost_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inputfilepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapperfilepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reducerfilepath_;
    ::Host* outputhdfs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kHealthyMappersFieldNumber = 2,
    kTotalMappersFieldNumber = 3,
    kHealthyReducersFieldNumber = 4,
    kTotalReducersFieldNumber = 5,
    kAverageMappingPercentageDoneFieldNumber = 6,
    kAverageReducingPercentageDoneFieldNumber = 7,
  };
  // string timestamp = 1;
  void clear_timestamp();
  const std::string& timestamp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timestamp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);
  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(const std::string& value);
  std::string* _internal_mutable_timestamp();
  public:

  // int32 healthyMappers = 2;
  void clear_healthymappers();
  int32_t healthymappers() const;
  void set_healthymappers(int32_t value);
  private:
  int32_t _internal_healthymappers() const;
  void _internal_set_healthymappers(int32_t value);
  public:

  // int32 totalMappers = 3;
  void clear_totalmappers();
  int32_t totalmappers() const;
  void set_totalmappers(int32_t value);
  private:
  int32_t _internal_totalmappers() const;
  void _internal_set_totalmappers(int32_t value);
  public:

  // int32 healthyReducers = 4;
  void clear_healthyreducers();
  int32_t healthyreducers() const;
  void set_healthyreducers(int32_t value);
  private:
  int32_t _internal_healthyreducers() const;
  void _internal_set_healthyreducers(int32_t value);
  public:

  // int32 totalReducers = 5;
  void clear_totalreducers();
  int32_t totalreducers() const;
  void set_totalreducers(int32_t value);
  private:
  int32_t _internal_totalreducers() const;
  void _internal_set_totalreducers(int32_t value);
  public:

  // int32 averageMappingPercentageDone = 6;
  void clear_averagemappingpercentagedone();
  int32_t averagemappingpercentagedone() const;
  void set_averagemappingpercentagedone(int32_t value);
  private:
  int32_t _internal_averagemappingpercentagedone() const;
  void _internal_set_averagemappingpercentagedone(int32_t value);
  public:

  // int32 averageReducingPercentageDone = 7;
  void clear_averagereducingpercentagedone();
  int32_t averagereducingpercentagedone() const;
  void set_averagereducingpercentagedone(int32_t value);
  private:
  int32_t _internal_averagereducingpercentagedone() const;
  void _internal_set_averagereducingpercentagedone(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    int32_t healthymappers_;
    int32_t totalmappers_;
    int32_t healthyreducers_;
    int32_t totalreducers_;
    int32_t averagemappingpercentagedone_;
    int32_t averagereducingpercentagedone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class MapperConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MapperConfigRequest) */ {
 public:
  inline MapperConfigRequest() : MapperConfigRequest(nullptr) {}
  ~MapperConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR MapperConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapperConfigRequest(const MapperConfigRequest& from);
  MapperConfigRequest(MapperConfigRequest&& from) noexcept
    : MapperConfigRequest() {
    *this = ::std::move(from);
  }

  inline MapperConfigRequest& operator=(const MapperConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapperConfigRequest& operator=(MapperConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapperConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapperConfigRequest* internal_default_instance() {
    return reinterpret_cast<const MapperConfigRequest*>(
               &_MapperConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MapperConfigRequest& a, MapperConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MapperConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapperConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapperConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapperConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapperConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapperConfigRequest& from) {
    MapperConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapperConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapperConfigRequest";
  }
  protected:
  explicit MapperConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReducerHDFSServicesFieldNumber = 4,
    kHDFSServiceFieldNumber = 1,
  };
  // repeated .Host reducerHDFSServices = 4;
  int reducerhdfsservices_size() const;
  private:
  int _internal_reducerhdfsservices_size() const;
  public:
  void clear_reducerhdfsservices();
  ::Host* mutable_reducerhdfsservices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
      mutable_reducerhdfsservices();
  private:
  const ::Host& _internal_reducerhdfsservices(int index) const;
  ::Host* _internal_add_reducerhdfsservices();
  public:
  const ::Host& reducerhdfsservices(int index) const;
  ::Host* add_reducerhdfsservices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
      reducerhdfsservices() const;

  // .Host hDFSService = 1;
  bool has_hdfsservice() const;
  private:
  bool _internal_has_hdfsservice() const;
  public:
  void clear_hdfsservice();
  const ::Host& hdfsservice() const;
  PROTOBUF_NODISCARD ::Host* release_hdfsservice();
  ::Host* mutable_hdfsservice();
  void set_allocated_hdfsservice(::Host* hdfsservice);
  private:
  const ::Host& _internal_hdfsservice() const;
  ::Host* _internal_mutable_hdfsservice();
  public:
  void unsafe_arena_set_allocated_hdfsservice(
      ::Host* hdfsservice);
  ::Host* unsafe_arena_release_hdfsservice();

  // @@protoc_insertion_point(class_scope:MapperConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host > reducerhdfsservices_;
    ::Host* hdfsservice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class ReducerKeys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReducerKeys) */ {
 public:
  inline ReducerKeys() : ReducerKeys(nullptr) {}
  ~ReducerKeys() override;
  explicit PROTOBUF_CONSTEXPR ReducerKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReducerKeys(const ReducerKeys& from);
  ReducerKeys(ReducerKeys&& from) noexcept
    : ReducerKeys() {
    *this = ::std::move(from);
  }

  inline ReducerKeys& operator=(const ReducerKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReducerKeys& operator=(ReducerKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReducerKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReducerKeys* internal_default_instance() {
    return reinterpret_cast<const ReducerKeys*>(
               &_ReducerKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReducerKeys& a, ReducerKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(ReducerKeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReducerKeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReducerKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReducerKeys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReducerKeys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReducerKeys& from) {
    ReducerKeys::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReducerKeys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReducerKeys";
  }
  protected:
  explicit ReducerKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:ReducerKeys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class MapperResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MapperResult) */ {
 public:
  inline MapperResult() : MapperResult(nullptr) {}
  ~MapperResult() override;
  explicit PROTOBUF_CONSTEXPR MapperResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapperResult(const MapperResult& from);
  MapperResult(MapperResult&& from) noexcept
    : MapperResult() {
    *this = ::std::move(from);
  }

  inline MapperResult& operator=(const MapperResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapperResult& operator=(MapperResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapperResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapperResult* internal_default_instance() {
    return reinterpret_cast<const MapperResult*>(
               &_MapperResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MapperResult& a, MapperResult& b) {
    a.Swap(&b);
  }
  inline void Swap(MapperResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapperResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapperResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapperResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapperResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapperResult& from) {
    MapperResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapperResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapperResult";
  }
  protected:
  explicit MapperResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentDoneFieldNumber = 2,
  };
  // int32 percentDone = 2;
  void clear_percentdone();
  int32_t percentdone() const;
  void set_percentdone(int32_t value);
  private:
  int32_t _internal_percentdone() const;
  void _internal_set_percentdone(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MapperResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t percentdone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class ReducerConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReducerConfigRequest) */ {
 public:
  inline ReducerConfigRequest() : ReducerConfigRequest(nullptr) {}
  ~ReducerConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ReducerConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReducerConfigRequest(const ReducerConfigRequest& from);
  ReducerConfigRequest(ReducerConfigRequest&& from) noexcept
    : ReducerConfigRequest() {
    *this = ::std::move(from);
  }

  inline ReducerConfigRequest& operator=(const ReducerConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReducerConfigRequest& operator=(ReducerConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReducerConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReducerConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ReducerConfigRequest*>(
               &_ReducerConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReducerConfigRequest& a, ReducerConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReducerConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReducerConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReducerConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReducerConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReducerConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReducerConfigRequest& from) {
    ReducerConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReducerConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReducerConfigRequest";
  }
  protected:
  explicit ReducerConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHDFSServiceFieldNumber = 2,
  };
  // .Host hDFSService = 2;
  bool has_hdfsservice() const;
  private:
  bool _internal_has_hdfsservice() const;
  public:
  void clear_hdfsservice();
  const ::Host& hdfsservice() const;
  PROTOBUF_NODISCARD ::Host* release_hdfsservice();
  ::Host* mutable_hdfsservice();
  void set_allocated_hdfsservice(::Host* hdfsservice);
  private:
  const ::Host& _internal_hdfsservice() const;
  ::Host* _internal_mutable_hdfsservice();
  public:
  void unsafe_arena_set_allocated_hdfsservice(
      ::Host* hdfsservice);
  ::Host* unsafe_arena_release_hdfsservice();

  // @@protoc_insertion_point(class_scope:ReducerConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Host* hdfsservice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class ReducerResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReducerResult) */ {
 public:
  inline ReducerResult() : ReducerResult(nullptr) {}
  ~ReducerResult() override;
  explicit PROTOBUF_CONSTEXPR ReducerResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReducerResult(const ReducerResult& from);
  ReducerResult(ReducerResult&& from) noexcept
    : ReducerResult() {
    *this = ::std::move(from);
  }

  inline ReducerResult& operator=(const ReducerResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReducerResult& operator=(ReducerResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReducerResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReducerResult* internal_default_instance() {
    return reinterpret_cast<const ReducerResult*>(
               &_ReducerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReducerResult& a, ReducerResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ReducerResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReducerResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReducerResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReducerResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReducerResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReducerResult& from) {
    ReducerResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReducerResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReducerResult";
  }
  protected:
  explicit ReducerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kPercentDoneFieldNumber = 3,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int32 percentDone = 3;
  void clear_percentdone();
  int32_t percentdone() const;
  void set_percentdone(int32_t value);
  private:
  int32_t _internal_percentdone() const;
  void _internal_set_percentdone(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReducerResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t percentdone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class HDFSMetaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HDFSMetaData) */ {
 public:
  inline HDFSMetaData() : HDFSMetaData(nullptr) {}
  ~HDFSMetaData() override;
  explicit PROTOBUF_CONSTEXPR HDFSMetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HDFSMetaData(const HDFSMetaData& from);
  HDFSMetaData(HDFSMetaData&& from) noexcept
    : HDFSMetaData() {
    *this = ::std::move(from);
  }

  inline HDFSMetaData& operator=(const HDFSMetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HDFSMetaData& operator=(HDFSMetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HDFSMetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HDFSMetaData* internal_default_instance() {
    return reinterpret_cast<const HDFSMetaData*>(
               &_HDFSMetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HDFSMetaData& a, HDFSMetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(HDFSMetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HDFSMetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HDFSMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HDFSMetaData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HDFSMetaData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HDFSMetaData& from) {
    HDFSMetaData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HDFSMetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HDFSMetaData";
  }
  protected:
  explicit HDFSMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoOfRecordsFieldNumber = 1,
  };
  // int64 noOfRecords = 1;
  void clear_noofrecords();
  int64_t noofrecords() const;
  void set_noofrecords(int64_t value);
  private:
  int64_t _internal_noofrecords() const;
  void _internal_set_noofrecords(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:HDFSMetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t noofrecords_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class SetRequestStream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetRequestStream) */ {
 public:
  inline SetRequestStream() : SetRequestStream(nullptr) {}
  ~SetRequestStream() override;
  explicit PROTOBUF_CONSTEXPR SetRequestStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRequestStream(const SetRequestStream& from);
  SetRequestStream(SetRequestStream&& from) noexcept
    : SetRequestStream() {
    *this = ::std::move(from);
  }

  inline SetRequestStream& operator=(const SetRequestStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequestStream& operator=(SetRequestStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRequestStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRequestStream* internal_default_instance() {
    return reinterpret_cast<const SetRequestStream*>(
               &_SetRequestStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetRequestStream& a, SetRequestStream& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequestStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequestStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRequestStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRequestStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetRequestStream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetRequestStream& from) {
    SetRequestStream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequestStream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetRequestStream";
  }
  protected:
  explicit SetRequestStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetRequestsFieldNumber = 1,
  };
  // repeated .SetRequest setRequests = 1;
  int setrequests_size() const;
  private:
  int _internal_setrequests_size() const;
  public:
  void clear_setrequests();
  ::SetRequest* mutable_setrequests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SetRequest >*
      mutable_setrequests();
  private:
  const ::SetRequest& _internal_setrequests(int index) const;
  ::SetRequest* _internal_add_setrequests();
  public:
  const ::SetRequest& setrequests(int index) const;
  ::SetRequest* add_setrequests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SetRequest >&
      setrequests() const;

  // @@protoc_insertion_point(class_scope:SetRequestStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SetRequest > setrequests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class SetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {}
  ~SetRequest() override;
  explicit PROTOBUF_CONSTEXPR SetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetRequest& from) {
    SetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class SetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetResponse) */ {
 public:
  inline SetResponse() : SetResponse(nullptr) {}
  ~SetResponse() override;
  explicit PROTOBUF_CONSTEXPR SetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetResponse(const SetResponse& from);
  SetResponse(SetResponse&& from) noexcept
    : SetResponse() {
    *this = ::std::move(from);
  }

  inline SetResponse& operator=(const SetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResponse& operator=(SetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetResponse* internal_default_instance() {
    return reinterpret_cast<const SetResponse*>(
               &_SetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetResponse& a, SetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetResponse& from) {
    SetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetResponse";
  }
  protected:
  explicit SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:SetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRequest& from) {
    GetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// -------------------------------------------------------------------

class StreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamResponse) */ {
 public:
  inline StreamResponse() : StreamResponse(nullptr) {}
  ~StreamResponse() override;
  explicit PROTOBUF_CONSTEXPR StreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamResponse(const StreamResponse& from);
  StreamResponse(StreamResponse&& from) noexcept
    : StreamResponse() {
    *this = ::std::move(from);
  }

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamResponse& operator=(StreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamResponse* internal_default_instance() {
    return reinterpret_cast<const StreamResponse*>(
               &_StreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StreamResponse& a, StreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamResponse& from) {
    StreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamResponse";
  }
  protected:
  explicit StreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:StreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_MapReduce_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Host

// string host = 1;
inline void Host::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Host::host() const {
  // @@protoc_insertion_point(field_get:Host.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Host::set_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Host.host)
}
inline std::string* Host::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:Host.host)
  return _s;
}
inline const std::string& Host::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Host::_internal_set_host(const std::string& value) {
  
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_host() {
  
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* Host::release_host() {
  // @@protoc_insertion_point(field_release:Host.host)
  return _impl_.host_.Release();
}
inline void Host::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Host.host)
}

// string port = 2;
inline void Host::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& Host::port() const {
  // @@protoc_insertion_point(field_get:Host.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Host::set_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Host.port)
}
inline std::string* Host::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:Host.port)
  return _s;
}
inline const std::string& Host::_internal_port() const {
  return _impl_.port_.Get();
}
inline void Host::_internal_set_port(const std::string& value) {
  
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* Host::_internal_mutable_port() {
  
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* Host::release_port() {
  // @@protoc_insertion_point(field_release:Host.port)
  return _impl_.port_.Release();
}
inline void Host::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Host.port)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Config

// optional string fileHost = 3;
inline bool Config::_internal_has_filehost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_filehost() const {
  return _internal_has_filehost();
}
inline void Config::clear_filehost() {
  _impl_.filehost_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::filehost() const {
  // @@protoc_insertion_point(field_get:Config.fileHost)
  return _internal_filehost();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_filehost(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filehost_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Config.fileHost)
}
inline std::string* Config::mutable_filehost() {
  std::string* _s = _internal_mutable_filehost();
  // @@protoc_insertion_point(field_mutable:Config.fileHost)
  return _s;
}
inline const std::string& Config::_internal_filehost() const {
  return _impl_.filehost_.Get();
}
inline void Config::_internal_set_filehost(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filehost_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_filehost() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filehost_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_filehost() {
  // @@protoc_insertion_point(field_release:Config.fileHost)
  if (!_internal_has_filehost()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filehost_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filehost_.IsDefault()) {
    _impl_.filehost_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Config::set_allocated_filehost(std::string* filehost) {
  if (filehost != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filehost_.SetAllocated(filehost, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filehost_.IsDefault()) {
    _impl_.filehost_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Config.fileHost)
}

// string inputFilePath = 4;
inline void Config::clear_inputfilepath() {
  _impl_.inputfilepath_.ClearToEmpty();
}
inline const std::string& Config::inputfilepath() const {
  // @@protoc_insertion_point(field_get:Config.inputFilePath)
  return _internal_inputfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_inputfilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.inputfilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Config.inputFilePath)
}
inline std::string* Config::mutable_inputfilepath() {
  std::string* _s = _internal_mutable_inputfilepath();
  // @@protoc_insertion_point(field_mutable:Config.inputFilePath)
  return _s;
}
inline const std::string& Config::_internal_inputfilepath() const {
  return _impl_.inputfilepath_.Get();
}
inline void Config::_internal_set_inputfilepath(const std::string& value) {
  
  _impl_.inputfilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_inputfilepath() {
  
  return _impl_.inputfilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_inputfilepath() {
  // @@protoc_insertion_point(field_release:Config.inputFilePath)
  return _impl_.inputfilepath_.Release();
}
inline void Config::set_allocated_inputfilepath(std::string* inputfilepath) {
  if (inputfilepath != nullptr) {
    
  } else {
    
  }
  _impl_.inputfilepath_.SetAllocated(inputfilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inputfilepath_.IsDefault()) {
    _impl_.inputfilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Config.inputFilePath)
}

// string mapperFilePath = 5;
inline void Config::clear_mapperfilepath() {
  _impl_.mapperfilepath_.ClearToEmpty();
}
inline const std::string& Config::mapperfilepath() const {
  // @@protoc_insertion_point(field_get:Config.mapperFilePath)
  return _internal_mapperfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_mapperfilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapperfilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Config.mapperFilePath)
}
inline std::string* Config::mutable_mapperfilepath() {
  std::string* _s = _internal_mutable_mapperfilepath();
  // @@protoc_insertion_point(field_mutable:Config.mapperFilePath)
  return _s;
}
inline const std::string& Config::_internal_mapperfilepath() const {
  return _impl_.mapperfilepath_.Get();
}
inline void Config::_internal_set_mapperfilepath(const std::string& value) {
  
  _impl_.mapperfilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_mapperfilepath() {
  
  return _impl_.mapperfilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_mapperfilepath() {
  // @@protoc_insertion_point(field_release:Config.mapperFilePath)
  return _impl_.mapperfilepath_.Release();
}
inline void Config::set_allocated_mapperfilepath(std::string* mapperfilepath) {
  if (mapperfilepath != nullptr) {
    
  } else {
    
  }
  _impl_.mapperfilepath_.SetAllocated(mapperfilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapperfilepath_.IsDefault()) {
    _impl_.mapperfilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Config.mapperFilePath)
}

// string reducerFilePath = 6;
inline void Config::clear_reducerfilepath() {
  _impl_.reducerfilepath_.ClearToEmpty();
}
inline const std::string& Config::reducerfilepath() const {
  // @@protoc_insertion_point(field_get:Config.reducerFilePath)
  return _internal_reducerfilepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Config::set_reducerfilepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reducerfilepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Config.reducerFilePath)
}
inline std::string* Config::mutable_reducerfilepath() {
  std::string* _s = _internal_mutable_reducerfilepath();
  // @@protoc_insertion_point(field_mutable:Config.reducerFilePath)
  return _s;
}
inline const std::string& Config::_internal_reducerfilepath() const {
  return _impl_.reducerfilepath_.Get();
}
inline void Config::_internal_set_reducerfilepath(const std::string& value) {
  
  _impl_.reducerfilepath_.Set(value, GetArenaForAllocation());
}
inline std::string* Config::_internal_mutable_reducerfilepath() {
  
  return _impl_.reducerfilepath_.Mutable(GetArenaForAllocation());
}
inline std::string* Config::release_reducerfilepath() {
  // @@protoc_insertion_point(field_release:Config.reducerFilePath)
  return _impl_.reducerfilepath_.Release();
}
inline void Config::set_allocated_reducerfilepath(std::string* reducerfilepath) {
  if (reducerfilepath != nullptr) {
    
  } else {
    
  }
  _impl_.reducerfilepath_.SetAllocated(reducerfilepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reducerfilepath_.IsDefault()) {
    _impl_.reducerfilepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Config.reducerFilePath)
}

// .Host outputHDFS = 9;
inline bool Config::_internal_has_outputhdfs() const {
  return this != internal_default_instance() && _impl_.outputhdfs_ != nullptr;
}
inline bool Config::has_outputhdfs() const {
  return _internal_has_outputhdfs();
}
inline void Config::clear_outputhdfs() {
  if (GetArenaForAllocation() == nullptr && _impl_.outputhdfs_ != nullptr) {
    delete _impl_.outputhdfs_;
  }
  _impl_.outputhdfs_ = nullptr;
}
inline const ::Host& Config::_internal_outputhdfs() const {
  const ::Host* p = _impl_.outputhdfs_;
  return p != nullptr ? *p : reinterpret_cast<const ::Host&>(
      ::_Host_default_instance_);
}
inline const ::Host& Config::outputhdfs() const {
  // @@protoc_insertion_point(field_get:Config.outputHDFS)
  return _internal_outputhdfs();
}
inline void Config::unsafe_arena_set_allocated_outputhdfs(
    ::Host* outputhdfs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outputhdfs_);
  }
  _impl_.outputhdfs_ = outputhdfs;
  if (outputhdfs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Config.outputHDFS)
}
inline ::Host* Config::release_outputhdfs() {
  
  ::Host* temp = _impl_.outputhdfs_;
  _impl_.outputhdfs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Host* Config::unsafe_arena_release_outputhdfs() {
  // @@protoc_insertion_point(field_release:Config.outputHDFS)
  
  ::Host* temp = _impl_.outputhdfs_;
  _impl_.outputhdfs_ = nullptr;
  return temp;
}
inline ::Host* Config::_internal_mutable_outputhdfs() {
  
  if (_impl_.outputhdfs_ == nullptr) {
    auto* p = CreateMaybeMessage<::Host>(GetArenaForAllocation());
    _impl_.outputhdfs_ = p;
  }
  return _impl_.outputhdfs_;
}
inline ::Host* Config::mutable_outputhdfs() {
  ::Host* _msg = _internal_mutable_outputhdfs();
  // @@protoc_insertion_point(field_mutable:Config.outputHDFS)
  return _msg;
}
inline void Config::set_allocated_outputhdfs(::Host* outputhdfs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outputhdfs_;
  }
  if (outputhdfs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outputhdfs);
    if (message_arena != submessage_arena) {
      outputhdfs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outputhdfs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.outputhdfs_ = outputhdfs;
  // @@protoc_insertion_point(field_set_allocated:Config.outputHDFS)
}

// repeated .Host mappers = 11;
inline int Config::_internal_mappers_size() const {
  return _impl_.mappers_.size();
}
inline int Config::mappers_size() const {
  return _internal_mappers_size();
}
inline void Config::clear_mappers() {
  _impl_.mappers_.Clear();
}
inline ::Host* Config::mutable_mappers(int index) {
  // @@protoc_insertion_point(field_mutable:Config.mappers)
  return _impl_.mappers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
Config::mutable_mappers() {
  // @@protoc_insertion_point(field_mutable_list:Config.mappers)
  return &_impl_.mappers_;
}
inline const ::Host& Config::_internal_mappers(int index) const {
  return _impl_.mappers_.Get(index);
}
inline const ::Host& Config::mappers(int index) const {
  // @@protoc_insertion_point(field_get:Config.mappers)
  return _internal_mappers(index);
}
inline ::Host* Config::_internal_add_mappers() {
  return _impl_.mappers_.Add();
}
inline ::Host* Config::add_mappers() {
  ::Host* _add = _internal_add_mappers();
  // @@protoc_insertion_point(field_add:Config.mappers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
Config::mappers() const {
  // @@protoc_insertion_point(field_list:Config.mappers)
  return _impl_.mappers_;
}

// repeated .Host reducers = 12;
inline int Config::_internal_reducers_size() const {
  return _impl_.reducers_.size();
}
inline int Config::reducers_size() const {
  return _internal_reducers_size();
}
inline void Config::clear_reducers() {
  _impl_.reducers_.Clear();
}
inline ::Host* Config::mutable_reducers(int index) {
  // @@protoc_insertion_point(field_mutable:Config.reducers)
  return _impl_.reducers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
Config::mutable_reducers() {
  // @@protoc_insertion_point(field_mutable_list:Config.reducers)
  return &_impl_.reducers_;
}
inline const ::Host& Config::_internal_reducers(int index) const {
  return _impl_.reducers_.Get(index);
}
inline const ::Host& Config::reducers(int index) const {
  // @@protoc_insertion_point(field_get:Config.reducers)
  return _internal_reducers(index);
}
inline ::Host* Config::_internal_add_reducers() {
  return _impl_.reducers_.Add();
}
inline ::Host* Config::add_reducers() {
  ::Host* _add = _internal_add_reducers();
  // @@protoc_insertion_point(field_add:Config.reducers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
Config::reducers() const {
  // @@protoc_insertion_point(field_list:Config.reducers)
  return _impl_.reducers_;
}

// -------------------------------------------------------------------

// Result

// string timestamp = 1;
inline void Result::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& Result::timestamp() const {
  // @@protoc_insertion_point(field_get:Result.timestamp)
  return _internal_timestamp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Result::set_timestamp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timestamp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Result.timestamp)
}
inline std::string* Result::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:Result.timestamp)
  return _s;
}
inline const std::string& Result::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void Result::_internal_set_timestamp(const std::string& value) {
  
  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* Result::_internal_mutable_timestamp() {
  
  return _impl_.timestamp_.Mutable(GetArenaForAllocation());
}
inline std::string* Result::release_timestamp() {
  // @@protoc_insertion_point(field_release:Result.timestamp)
  return _impl_.timestamp_.Release();
}
inline void Result::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  _impl_.timestamp_.SetAllocated(timestamp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Result.timestamp)
}

// int32 healthyMappers = 2;
inline void Result::clear_healthymappers() {
  _impl_.healthymappers_ = 0;
}
inline int32_t Result::_internal_healthymappers() const {
  return _impl_.healthymappers_;
}
inline int32_t Result::healthymappers() const {
  // @@protoc_insertion_point(field_get:Result.healthyMappers)
  return _internal_healthymappers();
}
inline void Result::_internal_set_healthymappers(int32_t value) {
  
  _impl_.healthymappers_ = value;
}
inline void Result::set_healthymappers(int32_t value) {
  _internal_set_healthymappers(value);
  // @@protoc_insertion_point(field_set:Result.healthyMappers)
}

// int32 totalMappers = 3;
inline void Result::clear_totalmappers() {
  _impl_.totalmappers_ = 0;
}
inline int32_t Result::_internal_totalmappers() const {
  return _impl_.totalmappers_;
}
inline int32_t Result::totalmappers() const {
  // @@protoc_insertion_point(field_get:Result.totalMappers)
  return _internal_totalmappers();
}
inline void Result::_internal_set_totalmappers(int32_t value) {
  
  _impl_.totalmappers_ = value;
}
inline void Result::set_totalmappers(int32_t value) {
  _internal_set_totalmappers(value);
  // @@protoc_insertion_point(field_set:Result.totalMappers)
}

// int32 healthyReducers = 4;
inline void Result::clear_healthyreducers() {
  _impl_.healthyreducers_ = 0;
}
inline int32_t Result::_internal_healthyreducers() const {
  return _impl_.healthyreducers_;
}
inline int32_t Result::healthyreducers() const {
  // @@protoc_insertion_point(field_get:Result.healthyReducers)
  return _internal_healthyreducers();
}
inline void Result::_internal_set_healthyreducers(int32_t value) {
  
  _impl_.healthyreducers_ = value;
}
inline void Result::set_healthyreducers(int32_t value) {
  _internal_set_healthyreducers(value);
  // @@protoc_insertion_point(field_set:Result.healthyReducers)
}

// int32 totalReducers = 5;
inline void Result::clear_totalreducers() {
  _impl_.totalreducers_ = 0;
}
inline int32_t Result::_internal_totalreducers() const {
  return _impl_.totalreducers_;
}
inline int32_t Result::totalreducers() const {
  // @@protoc_insertion_point(field_get:Result.totalReducers)
  return _internal_totalreducers();
}
inline void Result::_internal_set_totalreducers(int32_t value) {
  
  _impl_.totalreducers_ = value;
}
inline void Result::set_totalreducers(int32_t value) {
  _internal_set_totalreducers(value);
  // @@protoc_insertion_point(field_set:Result.totalReducers)
}

// int32 averageMappingPercentageDone = 6;
inline void Result::clear_averagemappingpercentagedone() {
  _impl_.averagemappingpercentagedone_ = 0;
}
inline int32_t Result::_internal_averagemappingpercentagedone() const {
  return _impl_.averagemappingpercentagedone_;
}
inline int32_t Result::averagemappingpercentagedone() const {
  // @@protoc_insertion_point(field_get:Result.averageMappingPercentageDone)
  return _internal_averagemappingpercentagedone();
}
inline void Result::_internal_set_averagemappingpercentagedone(int32_t value) {
  
  _impl_.averagemappingpercentagedone_ = value;
}
inline void Result::set_averagemappingpercentagedone(int32_t value) {
  _internal_set_averagemappingpercentagedone(value);
  // @@protoc_insertion_point(field_set:Result.averageMappingPercentageDone)
}

// int32 averageReducingPercentageDone = 7;
inline void Result::clear_averagereducingpercentagedone() {
  _impl_.averagereducingpercentagedone_ = 0;
}
inline int32_t Result::_internal_averagereducingpercentagedone() const {
  return _impl_.averagereducingpercentagedone_;
}
inline int32_t Result::averagereducingpercentagedone() const {
  // @@protoc_insertion_point(field_get:Result.averageReducingPercentageDone)
  return _internal_averagereducingpercentagedone();
}
inline void Result::_internal_set_averagereducingpercentagedone(int32_t value) {
  
  _impl_.averagereducingpercentagedone_ = value;
}
inline void Result::set_averagereducingpercentagedone(int32_t value) {
  _internal_set_averagereducingpercentagedone(value);
  // @@protoc_insertion_point(field_set:Result.averageReducingPercentageDone)
}

// -------------------------------------------------------------------

// MapperConfigRequest

// .Host hDFSService = 1;
inline bool MapperConfigRequest::_internal_has_hdfsservice() const {
  return this != internal_default_instance() && _impl_.hdfsservice_ != nullptr;
}
inline bool MapperConfigRequest::has_hdfsservice() const {
  return _internal_has_hdfsservice();
}
inline void MapperConfigRequest::clear_hdfsservice() {
  if (GetArenaForAllocation() == nullptr && _impl_.hdfsservice_ != nullptr) {
    delete _impl_.hdfsservice_;
  }
  _impl_.hdfsservice_ = nullptr;
}
inline const ::Host& MapperConfigRequest::_internal_hdfsservice() const {
  const ::Host* p = _impl_.hdfsservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::Host&>(
      ::_Host_default_instance_);
}
inline const ::Host& MapperConfigRequest::hdfsservice() const {
  // @@protoc_insertion_point(field_get:MapperConfigRequest.hDFSService)
  return _internal_hdfsservice();
}
inline void MapperConfigRequest::unsafe_arena_set_allocated_hdfsservice(
    ::Host* hdfsservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hdfsservice_);
  }
  _impl_.hdfsservice_ = hdfsservice;
  if (hdfsservice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MapperConfigRequest.hDFSService)
}
inline ::Host* MapperConfigRequest::release_hdfsservice() {
  
  ::Host* temp = _impl_.hdfsservice_;
  _impl_.hdfsservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Host* MapperConfigRequest::unsafe_arena_release_hdfsservice() {
  // @@protoc_insertion_point(field_release:MapperConfigRequest.hDFSService)
  
  ::Host* temp = _impl_.hdfsservice_;
  _impl_.hdfsservice_ = nullptr;
  return temp;
}
inline ::Host* MapperConfigRequest::_internal_mutable_hdfsservice() {
  
  if (_impl_.hdfsservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::Host>(GetArenaForAllocation());
    _impl_.hdfsservice_ = p;
  }
  return _impl_.hdfsservice_;
}
inline ::Host* MapperConfigRequest::mutable_hdfsservice() {
  ::Host* _msg = _internal_mutable_hdfsservice();
  // @@protoc_insertion_point(field_mutable:MapperConfigRequest.hDFSService)
  return _msg;
}
inline void MapperConfigRequest::set_allocated_hdfsservice(::Host* hdfsservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hdfsservice_;
  }
  if (hdfsservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hdfsservice);
    if (message_arena != submessage_arena) {
      hdfsservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdfsservice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hdfsservice_ = hdfsservice;
  // @@protoc_insertion_point(field_set_allocated:MapperConfigRequest.hDFSService)
}

// repeated .Host reducerHDFSServices = 4;
inline int MapperConfigRequest::_internal_reducerhdfsservices_size() const {
  return _impl_.reducerhdfsservices_.size();
}
inline int MapperConfigRequest::reducerhdfsservices_size() const {
  return _internal_reducerhdfsservices_size();
}
inline void MapperConfigRequest::clear_reducerhdfsservices() {
  _impl_.reducerhdfsservices_.Clear();
}
inline ::Host* MapperConfigRequest::mutable_reducerhdfsservices(int index) {
  // @@protoc_insertion_point(field_mutable:MapperConfigRequest.reducerHDFSServices)
  return _impl_.reducerhdfsservices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >*
MapperConfigRequest::mutable_reducerhdfsservices() {
  // @@protoc_insertion_point(field_mutable_list:MapperConfigRequest.reducerHDFSServices)
  return &_impl_.reducerhdfsservices_;
}
inline const ::Host& MapperConfigRequest::_internal_reducerhdfsservices(int index) const {
  return _impl_.reducerhdfsservices_.Get(index);
}
inline const ::Host& MapperConfigRequest::reducerhdfsservices(int index) const {
  // @@protoc_insertion_point(field_get:MapperConfigRequest.reducerHDFSServices)
  return _internal_reducerhdfsservices(index);
}
inline ::Host* MapperConfigRequest::_internal_add_reducerhdfsservices() {
  return _impl_.reducerhdfsservices_.Add();
}
inline ::Host* MapperConfigRequest::add_reducerhdfsservices() {
  ::Host* _add = _internal_add_reducerhdfsservices();
  // @@protoc_insertion_point(field_add:MapperConfigRequest.reducerHDFSServices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Host >&
MapperConfigRequest::reducerhdfsservices() const {
  // @@protoc_insertion_point(field_list:MapperConfigRequest.reducerHDFSServices)
  return _impl_.reducerhdfsservices_;
}

// -------------------------------------------------------------------

// ReducerKeys

// repeated string keys = 1;
inline int ReducerKeys::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int ReducerKeys::keys_size() const {
  return _internal_keys_size();
}
inline void ReducerKeys::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* ReducerKeys::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:ReducerKeys.keys)
  return _s;
}
inline const std::string& ReducerKeys::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& ReducerKeys::keys(int index) const {
  // @@protoc_insertion_point(field_get:ReducerKeys.keys)
  return _internal_keys(index);
}
inline std::string* ReducerKeys::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:ReducerKeys.keys)
  return _impl_.keys_.Mutable(index);
}
inline void ReducerKeys::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ReducerKeys.keys)
}
inline void ReducerKeys::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ReducerKeys.keys)
}
inline void ReducerKeys::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ReducerKeys.keys)
}
inline void ReducerKeys::set_keys(int index, const char* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReducerKeys.keys)
}
inline std::string* ReducerKeys::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void ReducerKeys::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ReducerKeys.keys)
}
inline void ReducerKeys::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ReducerKeys.keys)
}
inline void ReducerKeys::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ReducerKeys.keys)
}
inline void ReducerKeys::add_keys(const char* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ReducerKeys.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReducerKeys::keys() const {
  // @@protoc_insertion_point(field_list:ReducerKeys.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReducerKeys::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:ReducerKeys.keys)
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// MapperResult

// int32 percentDone = 2;
inline void MapperResult::clear_percentdone() {
  _impl_.percentdone_ = 0;
}
inline int32_t MapperResult::_internal_percentdone() const {
  return _impl_.percentdone_;
}
inline int32_t MapperResult::percentdone() const {
  // @@protoc_insertion_point(field_get:MapperResult.percentDone)
  return _internal_percentdone();
}
inline void MapperResult::_internal_set_percentdone(int32_t value) {
  
  _impl_.percentdone_ = value;
}
inline void MapperResult::set_percentdone(int32_t value) {
  _internal_set_percentdone(value);
  // @@protoc_insertion_point(field_set:MapperResult.percentDone)
}

// -------------------------------------------------------------------

// ReducerConfigRequest

// .Host hDFSService = 2;
inline bool ReducerConfigRequest::_internal_has_hdfsservice() const {
  return this != internal_default_instance() && _impl_.hdfsservice_ != nullptr;
}
inline bool ReducerConfigRequest::has_hdfsservice() const {
  return _internal_has_hdfsservice();
}
inline void ReducerConfigRequest::clear_hdfsservice() {
  if (GetArenaForAllocation() == nullptr && _impl_.hdfsservice_ != nullptr) {
    delete _impl_.hdfsservice_;
  }
  _impl_.hdfsservice_ = nullptr;
}
inline const ::Host& ReducerConfigRequest::_internal_hdfsservice() const {
  const ::Host* p = _impl_.hdfsservice_;
  return p != nullptr ? *p : reinterpret_cast<const ::Host&>(
      ::_Host_default_instance_);
}
inline const ::Host& ReducerConfigRequest::hdfsservice() const {
  // @@protoc_insertion_point(field_get:ReducerConfigRequest.hDFSService)
  return _internal_hdfsservice();
}
inline void ReducerConfigRequest::unsafe_arena_set_allocated_hdfsservice(
    ::Host* hdfsservice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hdfsservice_);
  }
  _impl_.hdfsservice_ = hdfsservice;
  if (hdfsservice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ReducerConfigRequest.hDFSService)
}
inline ::Host* ReducerConfigRequest::release_hdfsservice() {
  
  ::Host* temp = _impl_.hdfsservice_;
  _impl_.hdfsservice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Host* ReducerConfigRequest::unsafe_arena_release_hdfsservice() {
  // @@protoc_insertion_point(field_release:ReducerConfigRequest.hDFSService)
  
  ::Host* temp = _impl_.hdfsservice_;
  _impl_.hdfsservice_ = nullptr;
  return temp;
}
inline ::Host* ReducerConfigRequest::_internal_mutable_hdfsservice() {
  
  if (_impl_.hdfsservice_ == nullptr) {
    auto* p = CreateMaybeMessage<::Host>(GetArenaForAllocation());
    _impl_.hdfsservice_ = p;
  }
  return _impl_.hdfsservice_;
}
inline ::Host* ReducerConfigRequest::mutable_hdfsservice() {
  ::Host* _msg = _internal_mutable_hdfsservice();
  // @@protoc_insertion_point(field_mutable:ReducerConfigRequest.hDFSService)
  return _msg;
}
inline void ReducerConfigRequest::set_allocated_hdfsservice(::Host* hdfsservice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hdfsservice_;
  }
  if (hdfsservice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hdfsservice);
    if (message_arena != submessage_arena) {
      hdfsservice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdfsservice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hdfsservice_ = hdfsservice;
  // @@protoc_insertion_point(field_set_allocated:ReducerConfigRequest.hDFSService)
}

// -------------------------------------------------------------------

// ReducerResult

// int32 percentDone = 3;
inline void ReducerResult::clear_percentdone() {
  _impl_.percentdone_ = 0;
}
inline int32_t ReducerResult::_internal_percentdone() const {
  return _impl_.percentdone_;
}
inline int32_t ReducerResult::percentdone() const {
  // @@protoc_insertion_point(field_get:ReducerResult.percentDone)
  return _internal_percentdone();
}
inline void ReducerResult::_internal_set_percentdone(int32_t value) {
  
  _impl_.percentdone_ = value;
}
inline void ReducerResult::set_percentdone(int32_t value) {
  _internal_set_percentdone(value);
  // @@protoc_insertion_point(field_set:ReducerResult.percentDone)
}

// string key = 1;
inline void ReducerResult::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ReducerResult::key() const {
  // @@protoc_insertion_point(field_get:ReducerResult.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReducerResult::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReducerResult.key)
}
inline std::string* ReducerResult::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ReducerResult.key)
  return _s;
}
inline const std::string& ReducerResult::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ReducerResult::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ReducerResult::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ReducerResult::release_key() {
  // @@protoc_insertion_point(field_release:ReducerResult.key)
  return _impl_.key_.Release();
}
inline void ReducerResult::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReducerResult.key)
}

// string value = 2;
inline void ReducerResult::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ReducerResult::value() const {
  // @@protoc_insertion_point(field_get:ReducerResult.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReducerResult::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReducerResult.value)
}
inline std::string* ReducerResult::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ReducerResult.value)
  return _s;
}
inline const std::string& ReducerResult::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ReducerResult::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ReducerResult::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ReducerResult::release_value() {
  // @@protoc_insertion_point(field_release:ReducerResult.value)
  return _impl_.value_.Release();
}
inline void ReducerResult::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReducerResult.value)
}

// -------------------------------------------------------------------

// HDFSMetaData

// int64 noOfRecords = 1;
inline void HDFSMetaData::clear_noofrecords() {
  _impl_.noofrecords_ = int64_t{0};
}
inline int64_t HDFSMetaData::_internal_noofrecords() const {
  return _impl_.noofrecords_;
}
inline int64_t HDFSMetaData::noofrecords() const {
  // @@protoc_insertion_point(field_get:HDFSMetaData.noOfRecords)
  return _internal_noofrecords();
}
inline void HDFSMetaData::_internal_set_noofrecords(int64_t value) {
  
  _impl_.noofrecords_ = value;
}
inline void HDFSMetaData::set_noofrecords(int64_t value) {
  _internal_set_noofrecords(value);
  // @@protoc_insertion_point(field_set:HDFSMetaData.noOfRecords)
}

// -------------------------------------------------------------------

// SetRequestStream

// repeated .SetRequest setRequests = 1;
inline int SetRequestStream::_internal_setrequests_size() const {
  return _impl_.setrequests_.size();
}
inline int SetRequestStream::setrequests_size() const {
  return _internal_setrequests_size();
}
inline void SetRequestStream::clear_setrequests() {
  _impl_.setrequests_.Clear();
}
inline ::SetRequest* SetRequestStream::mutable_setrequests(int index) {
  // @@protoc_insertion_point(field_mutable:SetRequestStream.setRequests)
  return _impl_.setrequests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SetRequest >*
SetRequestStream::mutable_setrequests() {
  // @@protoc_insertion_point(field_mutable_list:SetRequestStream.setRequests)
  return &_impl_.setrequests_;
}
inline const ::SetRequest& SetRequestStream::_internal_setrequests(int index) const {
  return _impl_.setrequests_.Get(index);
}
inline const ::SetRequest& SetRequestStream::setrequests(int index) const {
  // @@protoc_insertion_point(field_get:SetRequestStream.setRequests)
  return _internal_setrequests(index);
}
inline ::SetRequest* SetRequestStream::_internal_add_setrequests() {
  return _impl_.setrequests_.Add();
}
inline ::SetRequest* SetRequestStream::add_setrequests() {
  ::SetRequest* _add = _internal_add_setrequests();
  // @@protoc_insertion_point(field_add:SetRequestStream.setRequests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SetRequest >&
SetRequestStream::setrequests() const {
  // @@protoc_insertion_point(field_list:SetRequestStream.setRequests)
  return _impl_.setrequests_;
}

// -------------------------------------------------------------------

// SetRequest

// string key = 1;
inline void SetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:SetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetRequest.key)
}
inline std::string* SetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:SetRequest.key)
  return _s;
}
inline const std::string& SetRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SetRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SetRequest::release_key() {
  // @@protoc_insertion_point(field_release:SetRequest.key)
  return _impl_.key_.Release();
}
inline void SetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SetRequest.key)
}

// string value = 2;
inline void SetRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:SetRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:SetRequest.value)
  return _s;
}
inline const std::string& SetRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:SetRequest.value)
  return _impl_.value_.Release();
}
inline void SetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SetRequest.value)
}

// -------------------------------------------------------------------

// SetResponse

// string message = 1;
inline void SetResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SetResponse::message() const {
  // @@protoc_insertion_point(field_get:SetResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetResponse.message)
}
inline std::string* SetResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:SetResponse.message)
  return _s;
}
inline const std::string& SetResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SetResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SetResponse::release_message() {
  // @@protoc_insertion_point(field_release:SetResponse.message)
  return _impl_.message_.Release();
}
inline void SetResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SetResponse.message)
}

// -------------------------------------------------------------------

// GetRequest

// string key = 1;
inline void GetRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:GetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRequest.key)
}
inline std::string* GetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:GetRequest.key)
  return _s;
}
inline const std::string& GetRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:GetRequest.key)
  return _impl_.key_.Release();
}
inline void GetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRequest.key)
}

// -------------------------------------------------------------------

// GetResponse

// string value = 1;
inline void GetResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:GetResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetResponse.value)
}
inline std::string* GetResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:GetResponse.value)
  return _s;
}
inline const std::string& GetResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:GetResponse.value)
  return _impl_.value_.Release();
}
inline void GetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetResponse.value)
}

// -------------------------------------------------------------------

// StreamResponse

// string key = 1;
inline void StreamResponse::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StreamResponse::key() const {
  // @@protoc_insertion_point(field_get:StreamResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamResponse.key)
}
inline std::string* StreamResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StreamResponse.key)
  return _s;
}
inline const std::string& StreamResponse::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StreamResponse::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamResponse::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamResponse::release_key() {
  // @@protoc_insertion_point(field_release:StreamResponse.key)
  return _impl_.key_.Release();
}
inline void StreamResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamResponse.key)
}

// string value = 2;
inline void StreamResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StreamResponse::value() const {
  // @@protoc_insertion_point(field_get:StreamResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamResponse.value)
}
inline std::string* StreamResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:StreamResponse.value)
  return _s;
}
inline const std::string& StreamResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StreamResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamResponse::release_value() {
  // @@protoc_insertion_point(field_release:StreamResponse.value)
  return _impl_.value_.Release();
}
inline void StreamResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamResponse.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MapReduce_2eproto
